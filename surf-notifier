import os
import requests
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
import logging
import sys
import asyncio
from telegram.ext import Application

# import keys

UK_TZ = ZoneInfo("Europe/London")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SurfNotifier:
    def __init__(self):
        # self.api_key = keys.STORMGLASS_API_KEY
        self.api_key = os.getenv('STORMGLASS_API_KEY')
        self.lat = 51.4854
        self.lng = -3.7031
        self.params = ['waveHeight', 'wavePeriod', 'waveDirection', 'windSpeed', 'windDirection']
        # self.bot_token = keys.TELEGRAM_TOKEN
        # self.chat_id = keys.TELEGRAM_CHAT_ID
        self.bot_token = os.getenv('TELEGRAM_TOKEN')
        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')
        if not all([self.api_key, self.bot_token, self.chat_id]):
            logger.error("Missing required environment variables: STORMGLASS_API_KEY, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID")
            sys.exit(1)

    def fetch_weather_data(self, start, end):
        url = "https://api.stormglass.io/v2/weather/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'params': ','.join(self.params),
            'start': start.isoformat(),
            'end': end.isoformat(),
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('hours', [])
        except Exception as e:
            logger.error(f"Error fetching weather data: {e}")
            return []

    def fetch_tide_data(self, start, end):
        url = "https://api.stormglass.io/v2/tide/extremes/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': start.isoformat(),
            'end': end.isoformat(),
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])
        except Exception as e:
            logger.error(f"Error fetching tide data: {e}")
            return []

    def fetch_sun_times(self, start, end):
        url = "https://api.stormglass.io/v2/astronomy/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': start.isoformat(),
            'end': end.isoformat(),
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])
        except Exception as e:
            logger.error(f"Error fetching sun data: {e}")
            return []

    def get_param_value(self, hour_data, param):
        if param in hour_data and isinstance(hour_data[param], dict):
            for _, value in hour_data[param].items():
                if value is not None:
                    return value
        return None

    def calculate_score(self, wave_height, wave_period, wind_speed, wind_direction, wave_direction):
        score = 0
        if wave_height:
            if 1.0 <= wave_height <= 2.5:
                score += 35
            elif 0.5 <= wave_height < 1.0:
                score += 25
            elif 2.5 < wave_height <= 4.0:
                score += 20
            elif wave_height > 4.0:
                score += 5

        if wave_period:
            if wave_period >= 12:
                score += 25
            elif wave_period >= 8:
                score += 20
            elif wave_period >= 6:
                score += 15
            else:
                score += 5

        if wind_speed and wind_direction and wave_direction:
            wind_relative = abs(wind_direction - wave_direction)
            if wind_relative > 180:
                wind_relative = 360 - wind_relative
            if wind_relative > 135:
                if wind_speed <= 5:
                    score += 25
                elif wind_speed <= 10:
                    score += 20
                else:
                    score += 10
            elif wind_relative < 45:
                score += 5
            else:
                score += 15

        if wind_speed and wind_speed > 15:
            score -= 10

        return max(0, min(100, score))

    def summarise_day(self, date, day_hours):
        if not day_hours:
            return None, None, []

        scores = []
        mid_hour = day_hours[len(day_hours) // 2]
        for hour in day_hours:
            values = [self.get_param_value(hour, p) for p in self.params]
            scores.append(self.calculate_score(*values))

        midday_values = [self.get_param_value(mid_hour, p) for p in self.params]
        avg_score = sum(scores) / len(scores)
        return avg_score, midday_values, day_hours

    def calculate_wingfoiling_score(self, tides, sun_data, day_hours):
        if not sun_data or not tides or not day_hours:
            return 0

        sunrise = sun_data.get('sunrise')
        sunset = sun_data.get('sunset')
        if not sunrise or not sunset:
            return 0
        sunrise_dt = datetime.fromisoformat(sunrise)
        sunset_dt = datetime.fromisoformat(sunset)

        low_tides = [t for t in tides if t['type'] == 'low']
        low_tide_daylight = [t for t in low_tides
                             if sunrise_dt <= datetime.fromisoformat(t['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ) <= sunset_dt]
        if not low_tide_daylight:
            return 0

        low_tide_time = min(low_tide_daylight, key=lambda t: datetime.fromisoformat(t['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ))
        target_time = datetime.fromisoformat(low_tide_time['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ) - timedelta(hours=1)

        closest_hour = min(day_hours, key=lambda h: abs(datetime.fromisoformat(h['time']).astimezone(UK_TZ) - target_time))
        wind_speed = self.get_param_value(closest_hour, 'windSpeed')
        wind_direction = self.get_param_value(closest_hour, 'windDirection')

        wind_speed_knots = wind_speed * 1.94384 if wind_speed is not None else 0
        score = 0

        if wind_speed_knots > 25:
            score += 10
        elif wind_speed_knots > 15:
            score += 40
        elif wind_speed_knots > 12:
            score += 10

        if wind_direction is not None and wind_speed_knots >= 12:
            if 220 < wind_direction < 230:
                score += 50
            if 200 < wind_direction <= 230:
                score += 60
            if 180 < wind_direction <= 200:
                score += 40
            if 220 < wind_direction <= 250:
                score += 60
            if 250 < wind_direction <= 270:
                score += 40
        return score

    async def notify(self, message):
        app = Application.builder().token(self.bot_token).build()
        try:
            await app.bot.send_message(chat_id=self.chat_id, text=message)
            logger.info("Notification sent successfully")
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        finally:
            await app.shutdown()

    async def run(self):
        today = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
        end = today + timedelta(days=5)

        raw_weather = self.fetch_weather_data(today, end)
        raw_tides = self.fetch_tide_data(today, end)
        raw_sun = self.fetch_sun_times(today, end)

        grouped_weather = {}
        for hour in raw_weather:
            date_str = datetime.fromisoformat(hour['time']).astimezone(UK_TZ).strftime('%Y-%m-%d')
            grouped_weather.setdefault(date_str, []).append(hour)

        grouped_tides = {}
        for tide in raw_tides:
            date_str = datetime.fromisoformat(tide['time']).astimezone(UK_TZ).strftime('%Y-%m-%d')
            grouped_tides.setdefault(date_str, []).append(tide)

        grouped_sun = {}
        for sun in raw_sun:
            date_str = datetime.fromisoformat(sun['time']).astimezone(UK_TZ).strftime('%Y-%m-%d')
            grouped_sun[date_str] = sun

        forecasts = {}
        for i in range(6):
            date = today + timedelta(days=i)
            date_str = date.astimezone(UK_TZ).strftime('%Y-%m-%d')
            weather = grouped_weather.get(date_str, [])
            tide = grouped_tides.get(date_str, [])
            sun = grouped_sun.get(date_str, {})
            avg_score, midday_vals, day_hours = self.summarise_day(date, weather)
            if avg_score is not None:
                wing_score = self.calculate_wingfoiling_score(tide, sun, day_hours)
                forecasts[date_str] = {
                    'score': avg_score,
                    'midday': midday_vals,
                    'wing_score': wing_score,
                    'tides': tide,
                    'sun': sun
                }

        if not forecasts:
            await self.notify("No forecast data available.")
            return

        best_surf_day = max(forecasts.items(), key=lambda kv: kv[1]['score'])
        best_wing_day = max(forecasts.items(), key=lambda kv: kv[1]['wing_score'])

        today_str = today.astimezone(UK_TZ).strftime('%Y-%m-%d')
        today_forecast = forecasts[today_str]

        def format_tides(tides):
            if not tides:
                return "No tide data"
            return "\n".join([
                f"{t['type'].capitalize()} tide: {datetime.fromisoformat(t['time']).astimezone(UK_TZ).strftime('%H:%M')}"
                for t in tides
            ])

        def forecast_block(label, forecast):
            vals = forecast['midday']
            wave_h, wave_p, wave_d, wind_s, wind_d = vals
            wind_knots = wind_s * 1.94384 if wind_s is not None else None

            sun = forecast['sun']
            sunrise = sun.get('sunrise')
            sunset = sun.get('sunset')
            if sunrise:
                sunrise = datetime.fromisoformat(sunrise).astimezone(UK_TZ).strftime('%H:%M')
            if sunset:
                sunset = datetime.fromisoformat(sunset).astimezone(UK_TZ).strftime('%H:%M')

            wing_score = forecast.get('wing_score', 0)

            return f"""
ðŸ„â€â™‚ï¸ {label}
Surf Score: {forecast['score']:.0f}/100
Wingfoiling Score: {wing_score}/100
Wave Height: {wave_h:.2f} m
Wave Period: {wave_p:.1f} s
Wind Speed: {wind_knots:.1f} kt
Wind Direction: {wind_d:.0f}Â°
ðŸŒ… Sunrise: {sunrise} | Sunset: {sunset}
ðŸŒŠ Tide Times:
{format_tides(forecast['tides'])}
"""

        five_day_summary = ""
        for i in range(1, 6):
            date = today + timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            forecast = forecasts.get(date_str)
            if forecast:
                five_day_summary += f"{date.strftime('%A')}: Surf Score: {forecast['score']:.0f}/100, Wing Score: {forecast['wing_score']}/100\n"

        message = f"""ðŸ„â€â™‚ï¸ Rest Bay Surf & Wingfoil Forecast - {today.strftime('%A %d %B %Y')}

{forecast_block("Today", today_forecast)}
{five_day_summary}
{forecast_block(f"Best Surf Day: {datetime.fromisoformat(best_surf_day[0]).strftime('%A')}", best_surf_day[1])}
{forecast_block(f"Best Wingfoil Day: {datetime.fromisoformat(best_wing_day[0]).strftime('%A')}", best_wing_day[1])}

Check it out here: https://www.surfline.com/surf-report/rest-bay/584204204e65fad6a77090d2?camId=5a21a9cff20eb500195b40ca&view=table
"""
        await self.notify(message.strip())

if __name__ == "__main__":
    notifier = SurfNotifier()
    asyncio.run(notifier.run())
