import os
import requests
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import logging
import sys
import asyncio
from telegram.ext import Application

UK_TZ = ZoneInfo("Europe/London")  # ‚úÖ UK timezone for BST/GMT

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SurfNotifier:
    def __init__(self):
        self.api_key = os.getenv('STORMGLASS_API_KEY')
        self.lat = 51.4854
        self.lng = -3.7031
        self.params = ['waveHeight', 'wavePeriod', 'waveDirection', 'windSpeed', 'windDirection']
        self.bot_token = os.getenv('TELEGRAM_TOKEN')
        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')
        if not all([self.api_key, self.bot_token, self.chat_id]):
            logger.error("Missing required environment variables: STORMGLASS_API_KEY, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID")
            sys.exit(1)

    def fetch_weather_data(self, start, end):
        url = "https://api.stormglass.io/v2/weather/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'params': ','.join(self.params),
            'start': start.isoformat(),
            'end': end.isoformat(),
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('hours', [])
        except Exception as e:
            logger.error(f"Error fetching weather data: {e}")
            return []

    def fetch_tide_data(self, date):
        url = "https://api.stormglass.io/v2/tide/extremes/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': date.isoformat(),
            'end': (date + timedelta(days=1)).isoformat()
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])
        except Exception as e:
            logger.error(f"Error fetching tide data: {e}")
            return []

    def fetch_sun_times(self, date):
        url = "https://api.stormglass.io/v2/astronomy/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': date.isoformat(),
            'end': (date + timedelta(days=1)).isoformat()
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])[0]
        except Exception as e:
            logger.error(f"Error fetching sun data: {e}")
            return {}

    def get_param_value(self, hour_data, param):
        if param in hour_data and isinstance(hour_data[param], dict):
            for _, value in hour_data[param].items():
                if value is not None:
                    return value
        return None

    def calculate_score(self, wave_height, wave_period, wind_speed, wind_direction, wave_direction):
        score = 0
        if wave_height:
            if 1.0 <= wave_height <= 2.5:
                score += 35
            elif 0.5 <= wave_height < 1.0:
                score += 25
            elif 2.5 < wave_height <= 4.0:
                score += 20
            elif wave_height > 4.0:
                score += 5

        if wave_period:
            if wave_period >= 12:
                score += 25
            elif wave_period >= 8:
                score += 20
            elif wave_period >= 6:
                score += 15
            else:
                score += 0

        if wind_speed and wind_direction and wave_direction:
            wind_relative = abs(wind_direction - wave_direction)
            if wind_relative > 180:
                wind_relative = 360 - wind_relative
            if wind_relative > 135:
                if wind_speed <= 5:
                    score += 25
                elif wind_speed <= 10:
                    score += 20
                else:
                    score += 10
            elif wind_relative < 45:
                score += 5
            else:
                score += 15

        if wind_speed and wind_speed > 15:
            score -= 10

        return max(0, min(100, score))

    def summarise_day(self, date, data):
        day_hours = [d for d in data if datetime.fromisoformat(d['time']).astimezone(UK_TZ).date() == date.date()]  # ‚úÖ timezone-aware
        if not day_hours:
            return None, None

        scores = []
        mid_hour = day_hours[len(day_hours) // 2]
        for hour in day_hours:
            values = [self.get_param_value(hour, p) for p in self.params]
            scores.append(self.calculate_score(*values))

        midday_values = [self.get_param_value(mid_hour, p) for p in self.params]
        avg_score = sum(scores) / len(scores)
        return avg_score, midday_values

    async def notify(self, message):
        app = Application.builder().token(self.bot_token).build()
        try:
            await app.bot.send_message(chat_id=self.chat_id, text=message)
            logger.info("Notification sent successfully")
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        finally:
            await app.shutdown()

    async def run(self):
        today = datetime.now(UK_TZ).replace(hour=0, minute=0, second=0, microsecond=0)  # ‚úÖ BST/GMT aware
        end = today + timedelta(days=5)
        all_data = self.fetch_weather_data(today, end)

        forecasts = {}
        for i in range(5):
            date = today + timedelta(days=i)
            avg_score, midday_vals = self.summarise_day(date, all_data)
            if avg_score is not None:
                forecasts[date] = {'score': avg_score, 'midday': midday_vals}

        if not forecasts:
            await self.notify("No forecast data available.")
            return

        best_day = max(forecasts.items(), key=lambda kv: kv[1]['score'])
        today_vals = forecasts[today]['midday']
        today_score = forecasts[today]['score']

        # Tide and sun
        tides = self.fetch_tide_data(today)
        tide_str = "\n".join([f"{t['type'].capitalize()} tide: {datetime.fromisoformat(t['time']).astimezone(UK_TZ).strftime('%H:%M')}"
                              for t in tides if datetime.fromisoformat(t['time']).astimezone(UK_TZ).date() == today.date()])  # ‚úÖ BST

        sun_data = self.fetch_sun_times(today)
        sunrise = sun_data.get('sunrise')
        sunset = sun_data.get('sunset')
        if sunrise: sunrise = datetime.fromisoformat(sunrise).astimezone(UK_TZ).strftime('%H:%M')  # ‚úÖ
        if sunset: sunset = datetime.fromisoformat(sunset).astimezone(UK_TZ).strftime('%H:%M')    # ‚úÖ

        def forecast_block(label, score, vals):
            wave_h, wave_p, wave_d, wind_s, wind_d = vals
            wind_knots = wind_s * 1.94384 if wind_s is not None else None
            return f"""
üèÑ‚Äç‚ôÇÔ∏è {label}
Surf Score: {score:.0f}/100
Wave Height: {wave_h:.2f} m
Wave Period: {wave_p:.1f} s
Wave Direction: {wave_d:.0f}¬∞
Wind Direction: {wind_d:.0f}¬∞
Wind Speed: {wind_knots:.1f} kt
"""

        message = f"""üèÑ‚Äç‚ôÇÔ∏è Rest Bay Surf Forecast - {today.strftime('%A %d %B %Y')}

{forecast_block("Today", today_score, today_vals)}
{forecast_block(f"Best Day in the next 5: {best_day[0].strftime('%A')}", best_day[1]['score'], best_day[1]['midday'])}

üåÖ Sunrise: {sunrise} | Sunset: {sunset}
üåä Tide Times:
{tide_str or "No tide data"}

"""
        await self.notify(message.strip())

if __name__ == "__main__":
    notifier = SurfNotifier()
    asyncio.run(notifier.run())
