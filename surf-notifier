import os
import requests
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
import logging
import sys
import asyncio
from telegram.ext import Application

UK_TZ = ZoneInfo("Europe/London")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SurfNotifier:
    def __init__(self):
        self.api_key = os.getenv('STORMGLASS_API_KEY')
        self.lat = 51.4854
        self.lng = -3.7031
        self.params = ['waveHeight', 'wavePeriod', 'waveDirection', 'windSpeed', 'windDirection']
        self.bot_token = os.getenv('TELEGRAM_TOKEN')
        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')
        if not all([self.api_key, self.bot_token, self.chat_id]):
            logger.error("Missing required environment variables: STORMGLASS_API_KEY, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID")
            sys.exit(1)

    def fetch_weather_data(self, start, end):
        url = "https://api.stormglass.io/v2/weather/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'params': ','.join(self.params),
            'start': start.isoformat(),
            'end': end.isoformat(),
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('hours', [])
        except Exception as e:
            logger.error(f"Error fetching weather data: {e}")
            return []

    def fetch_tide_data(self, date):
        url = "https://api.stormglass.io/v2/tide/extremes/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': date.isoformat(),
            'end': (date + timedelta(days=1)).isoformat()
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])
        except Exception as e:
            logger.error(f"Error fetching tide data: {e}")
            return []

    def fetch_sun_times(self, date):
        url = "https://api.stormglass.io/v2/astronomy/point"
        params = {
            'lat': self.lat,
            'lng': self.lng,
            'start': date.isoformat(),
            'end': (date + timedelta(days=1)).isoformat()
        }
        headers = {'Authorization': self.api_key}
        try:
            response = requests.get(url, params=params, headers=headers)
            response.raise_for_status()
            return response.json().get('data', [])[0]
        except Exception as e:
            logger.error(f"Error fetching sun data: {e}")
            return {}

    def get_param_value(self, hour_data, param):
        if param in hour_data and isinstance(hour_data[param], dict):
            for _, value in hour_data[param].items():
                if value is not None:
                    return value
        return None

    def calculate_score(self, wave_height, wave_period, wind_speed, wind_direction, wave_direction):
        score = 0
        if wave_height:
            if 1.0 <= wave_height <= 2.5:
                score += 35
            elif 0.5 <= wave_height < 1.0:
                score += 25
            elif 2.5 < wave_height <= 4.0:
                score += 20
            elif wave_height > 4.0:
                score += 5

        if wave_period:
            if wave_period >= 12:
                score += 25
            elif wave_period >= 8:
                score += 20
            elif wave_period >= 6:
                score += 15
            else:
                score += 5

        if wind_speed and wind_direction and wave_direction:
            wind_relative = abs(wind_direction - wave_direction)
            if wind_relative > 180:
                wind_relative = 360 - wind_relative
            if wind_relative > 135:
                if wind_speed <= 5:
                    score += 25
                elif wind_speed <= 10:
                    score += 20
                else:
                    score += 10
            elif wind_relative < 45:
                score += 5
            else:
                score += 15

        if wind_speed and wind_speed > 15:
            score -= 10

        return max(0, min(100, score))

    def summarise_day(self, date, data):
        day_hours = [d for d in data if datetime.fromisoformat(d['time']).date() == date.date()]
        if not day_hours:
            return None, None

        scores = []
        mid_hour = day_hours[len(day_hours) // 2]
        for hour in day_hours:
            values = [self.get_param_value(hour, p) for p in self.params]
            scores.append(self.calculate_score(*values))

        midday_values = [self.get_param_value(mid_hour, p) for p in self.params]
        avg_score = sum(scores) / len(scores)
        return avg_score, midday_values, day_hours

    def calculate_wingfoiling_score(self, tides, sun_data, day_hours):
        wingfoiling_score = 0

        # Parse sunrise and sunset time as datetime
        sunrise = sun_data.get('sunrise')
        sunset = sun_data.get('sunset')
        if not sunrise or not sunset:
            return wingfoiling_score  # No sun data, no wingfoiling score
        sunrise_dt = datetime.fromisoformat(sunrise)
        sunset_dt = datetime.fromisoformat(sunset)

        # Find low tide within daylight hours
        low_tides = [t for t in tides if t['type'] == 'low']
        low_tide_daylight = [t for t in low_tides
                             if sunrise_dt <= datetime.fromisoformat(t['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ) <= sunset_dt]

        if not low_tide_daylight:
            return wingfoiling_score  # No low tide during daylight

        # Take earliest low tide during daylight for simplicity
        low_tide = min(
        low_tide_daylight,
        key=lambda t: datetime.fromisoformat(t['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ))
        low_tide_time = datetime.fromisoformat(low_tide['time']).replace(tzinfo=ZoneInfo("UTC")).astimezone(UK_TZ)

        # Find wind speed 1 hour before low tide
        target_time = low_tide_time - timedelta(hours=1)

        # Find closest hour data to target_time
        closest_hour = min(day_hours, key=lambda h: abs(datetime.fromisoformat(h['time']) - target_time))

        wind_speed = self.get_param_value(closest_hour, 'windSpeed')
        wind_direction = self.get_param_value(closest_hour, 'windDirection')

        # Convert wind speed m/s to knots (1 m/s = 1.94384 knots)
        if wind_speed is not None:
            wind_speed_knots = wind_speed * 1.94384
        else:
            wind_speed_knots = 0

        wingfoiling_score = 0

        # Wind speed scoring
        if wind_speed_knots > 25:
            wingfoiling_score += 10
        elif wind_speed_knots > 15:
            wingfoiling_score += 40
        elif wind_speed_knots > 12:
            wingfoiling_score += 10

        # Wind direction scoring
        if wind_direction is not None and wind_speed_knots >= 12:
            if 220 < wind_direction < 230:
                wingfoiling_score += 50
            if 200 < wind_direction <= 230:
                wingfoiling_score += 60
            if 180 < wind_direction <= 200:
                wingfoiling_score += 40
            if 220 < wind_direction <= 250:
                wingfoiling_score += 60
            if 250 < wind_direction <= 270:
                wingfoiling_score += 40
        return wingfoiling_score

    async def notify(self, message):
        app = Application.builder().token(self.bot_token).build()
        try:
            await app.bot.send_message(chat_id=self.chat_id, text=message)
            logger.info("Notification sent successfully")
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        finally:
            await app.shutdown()

    async def run(self):
        today = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
        end = today + timedelta(days=5)
        all_data = self.fetch_weather_data(today, end)

        # Fetch tide and sun data for each day upfront
        tide_data_by_date = {}
        sun_data_by_date = {}
        for i in range(5):
            date = today + timedelta(days=i)
            tide_data_by_date[date.date()] = self.fetch_tide_data(date)
            sun_data_by_date[date.date()] = self.fetch_sun_times(date)

        forecasts = {}
        for i in range(5):
            date = today + timedelta(days=i)
            avg_score, midday_vals, day_hours = self.summarise_day(date, all_data)
            if avg_score is not None:
                wing_score = self.calculate_wingfoiling_score(
                    tide_data_by_date.get(date.date(), []),
                    sun_data_by_date.get(date.date(), {}),
                    day_hours)
                forecasts[date] = {
                    'score': avg_score,
                    'midday': midday_vals,
                    'wing_score': wing_score,
                    'tides': tide_data_by_date.get(date.date(), []),
                    'sun': sun_data_by_date.get(date.date(), {})
                }

        if not forecasts:
            await self.notify("No forecast data available.")
            return

        best_surf_day = max(forecasts.items(), key=lambda kv: kv[1]['score'])
        best_wing_day = max(forecasts.items(), key=lambda kv: kv[1]['wing_score'])

        today_forecast = forecasts[today]

        def format_tides(tides):
            if not tides:
                return "No tide data"
            return "\n".join([
                f"{t['type'].capitalize()} tide: {datetime.fromisoformat(t['time']).astimezone(UK_TZ).strftime('%H:%M')}"
                for t in tides
            ])


        def forecast_block(label, forecast):
            vals = forecast['midday']
            wave_h, wave_p, wave_d, wind_s, wind_d = vals
            wind_knots = wind_s * 1.94384 if wind_s is not None else None

            sun = forecast['sun']
            sunrise = sun.get('sunrise')
            sunset = sun.get('sunset')
            if sunrise:
                sunrise = datetime.fromisoformat(sunrise).astimezone(UK_TZ).strftime('%H:%M')
            if sunset:
                sunset = datetime.fromisoformat(sunset).astimezone(UK_TZ).strftime('%H:%M')


            wing_score = forecast.get('wing_score', 0)

            return f"""
ðŸ„â€â™‚ï¸ {label}
Surf Score: {forecast['score']:.0f}/100
Wingfoiling Score: {wing_score}/100
Wave Height: {wave_h:.2f} m
Wave Period: {wave_p:.1f} s
Wind Speed: {wind_knots:.1f} kt
Wind Direction: {wind_d:.0f}Â°
ðŸŒ… Sunrise: {sunrise} | Sunset: {sunset}
ðŸŒŠ Tide Times:
{format_tides(forecast['tides'])}
"""

        message = f"""ðŸ„â€â™‚ï¸ Rest Bay Surf & Wingfoil Forecast - {today.strftime('%A %d %B %Y')}

{forecast_block("Today", today_forecast)}
{forecast_block(f"Best Surf Day in the next 5: {best_surf_day[0].strftime('%A')}", best_surf_day[1])}
{forecast_block(f"Best Wingfoil Day in the next 5: {best_wing_day[0].strftime('%A')}", best_wing_day[1])}
Check it out here: https://www.surfline.com/surf-report/rest-bay/584204204e65fad6a77090d2?camId=5a21a9cff20eb500195b40ca&view=table

"""
        await self.notify(message.strip())

if __name__ == "__main__":
    notifier = SurfNotifier()
    asyncio.run(notifier.run())
